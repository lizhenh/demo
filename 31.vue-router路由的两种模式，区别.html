<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    对于 Vue 这类渐进式前端开发框架，为了构建 SPA（单页面应用），需要引入前端路由系统，
    
    这也就是 Vue-Router 存在的意义。前端路由的核心，就在于 —— 改变视图的同时不会向后端发出请求。

    vue-router有两种模式，hash模式和history模式。

    hash模式url里面永远带着#号，我们在开发当中默认使用这个模式。那么什么时候要用history模式呢？
    如果用户考虑url的规范那么就需要使用history模式，因为history模式没有#号，
    是个正常的url适合推广宣传。当然其功能也有区别，比如我们在开发app的时候有分享页面，
    那么这个分享出去的页面就是用vue或是react做的，咱们把这个页面分享到第三方的app里
    ，有的app里面url是不允许带有#号的，所以要将#号去除那么就要使用history模式，
    但是使用history模式还有一个问题就是，在访问二级页面的时候，做刷新操作，会出现404错误，
    那么就需要和后端人配合让他配置一下apache或是nginx的url重定向，重定向到你的首页路由上就ok啦。

    路由的哈希模式其实是利用了window可以监听onhashchange事件，也就是说你的url中的哈希值（#后面的值）
    如果有变化，
    前端是可以做到监听并做一些响应（搞点事情），这么一来，
    即使前端并没有发起http请求他也能够找到对应页面的代码块进行按需加载。

    HTML5 history新增了两个API:history.pushState和history.replaceState

    两个API都接收三个参数：状态对象（state object）标题（title）地址（URL）

    hash与history的区别
	 
			hash                          history
url显示    有#，很Low                     无#，好看
回车刷新 可以加载到hash值对应页面        一般就是404掉了
支持版本 支持低版本浏览器和IE浏览器      HTML5新推出的API

另外，根据 Mozilla Develop Network 的介绍，调用 history.pushState() 相比于直接修改 hash，存在以下优势：
pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；
而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；
而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
pushState() 可额外设置 title 属性供后续使用。

hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.abc.com，
因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。
history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，
如 http://www.abc.com/book/id。如果后端缺少对 /book/id 的路由处理，将返回 404 错误。
Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，
你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，
则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”

    

</body>

</html>